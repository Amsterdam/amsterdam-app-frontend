# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

default_platform(:ios)

puts "ARTIFACT_FOLDER: #{ENV["ARTIFACT_FOLDER"]}"
puts "VERSION_NUMBER: #{ENV["VERSION_NUMBER"]}"

# The path to the .ipa files (artifact staging directory)
# we only set this in the release pipelines, this is a default to prevent errors during the build pipeline
ipa_path = ""

if ENV["ARTIFACT_FOLDER"]
  ipa_path = ENV["ARTIFACT_FOLDER"]
end

git_url = "git@ssh.dev.azure.com:v3/CloudCompetenceCenter/Amsterdam-App/Amsterdam-App-Frontend-iOS-Certificates"
if ENV["MATCH_GIT_BEARER_AUTHORIZATION"] || ENV["MATCH_GIT_BASIC_AUTHORIZATION"]
  git_url = "https://CloudCompetenceCenter@dev.azure.com/CloudCompetenceCenter/Amsterdam-App/_git/Amsterdam-App-Frontend-iOS-Certificates"
end

# Config for the test and production app
apps = [
  {
    :name => "amsterdam-test",
    :app_identifier => "nl.amsterdam.app.dev",
    :scheme => "AmsterdamApp Test",
    :matchRepoBranchName => "AmsterdamAppTest",
    :distribute_to_stakeholders => false,
    :distribute_to_production => false,
    :output_name => "AmsterdamTest.ipa",
  },
  {
    :name => "amsterdam",
    :app_identifier => "nl.amsterdam.app",
    :scheme => "AmsterdamApp",
    :matchRepoBranchName => "AmsterdamApp",
    :distribute_to_stakeholders => true,
    :distribute_to_production => true,
    :output_name => "Amsterdam.ipa",
  },
]

def parseVersionNumber(fullVersionNumber)
  if fullVersionNumber
    return fullVersionNumber.match /(?<version>\d+\.\d+\.\d+)\.(?<build>\d+)/
  else
    UI.user_error!("ERROR: parseVersionNumber failed")
  end
end

platform :ios do

  private_lane :installAppStoreApiKey do
    app_store_connect_api_key(
        key_id: "4B3KZ8N747",
        issuer_id: "69a6de97-c5e4-47e3-e053-5b8c7c11a4d1",
        key_filepath: './certs/App_Store_Connect_API_Key_4B3KZ8N747.p8',
        duration: 600,
        in_house: false,
      )
  end

  private_lane :syncCertificates do |options|
    apps.each do |app|
      puts "Sync certificates for #{app[:app_identifier]}"

      readonly = options.fetch(:readonly, false)

      if !readonly
        installAppStoreApiKey()
      end

      match(
        type: options.fetch(:type, 'development'),
        generate_apple_certs: true,
        app_identifier: app[:app_identifier],
        git_branch: app[:matchRepoBranchName],
        readonly: readonly,
        skip_provisioning_profiles: false,
        storage_mode: "git",
        git_url: git_url,
        git_full_name: "Amsterdam App",
        git_user_email: "app@amsterdam.nl",
        force_for_new_devices: true,
        include_mac_in_profiles: true,
        verbose: true,
      )
    end
  end

  desc "Sync development certificates"
  lane :syncDevelopment do
    syncCertificates()
  end

  desc "Sync appstore certificates"
  lane :syncAppstore do |options|
    syncCertificates(
      type: "appstore",
      **options,
    )
  end

  desc "Sync all certificates"
  lane :syncAll do
    syncDevelopment()
    syncAppstore()
  end

  desc "Build prod and dev version of the app"
  lane :buildApps do

    # We cannot switch the app identifier for the build_app task via a config setting, in this setup we can only set it for a lane (see Appfile).
    # Hence the multitude of lanes that seemingly do nothing.

    desc "Create single app build"
    private_lane :buildLane do |app|
        build_app(
          workspace: "AmsterdamApp.xcworkspace",
          scheme: app[:scheme],
          clean: true,
          build_path: "./builds",
          output_directory: "./builds",
          output_name: app[:output_name],
        )
    end

    desc "Production build"
    private_lane :prodLane do |app|
      buildLane(app)
    end

    desc "Dev build"
    private_lane :devLane do |app|
      buildLane(app)
    end

    syncAppstore(
      readonly: true,
    )

    cocoapods(
      clean_install: true,
      podfile: "./Podfile",
    )

    apps.each do |app|
      puts "Build #{app[:app_identifier]}"
      if app[:name] == "amsterdam-test"
        devLane(app)
      else
        prodLane(app)
      end
    end

    # TODO set_changelog()
  end

  lane :distributeInternal do

    installAppStoreApiKey()

    apps.each do |app|
      full_ipa_path =  "#{ipa_path}/#{app[:output_name]}"
      puts "Upload to testflight for #{full_ipa_path}"
      if File.exists?(full_ipa_path)
        upload_to_testflight(
          ipa: full_ipa_path,
          groups: "AmsterdamApp-scrumteam",
          app_version: parseVersionNumber(ENV["VERSION_NUMBER"])[:version],
          build_number: parseVersionNumber(ENV["VERSION_NUMBER"])[:build],
          app_identifier: app[:app_identifier],
        )
      else
        UI.user_error!("ERROR: #{ipa_path} does not exist")
      end
    end

  end

  lane :distributeStakeholders do

    installAppStoreApiKey()

    apps.each do |app|
      if app[:distribute_to_stakeholders]
        full_ipa_path =  "#{ipa_path}/#{app[:output_name]}"
        puts "Upload to testflight for #{full_ipa_path}"
        if File.exists?(full_ipa_path)
          upload_to_testflight(
            ipa: full_ipa_path,
            distribute_only: true,
            groups: "AmsterdamApp-stakeholders",
            app_version: parseVersionNumber(ENV["VERSION_NUMBER"])[:version],
            build_number: parseVersionNumber(ENV["VERSION_NUMBER"])[:build],
            app_identifier: app[:app_identifier],
          )
        else
          UI.user_error!("ERROR: #{ipa_path} does not exist")
        end
      end
    end

  end
  
  lane :distributeProduction do

    installAppStoreApiKey()
 
    apps.each do |app|
      if app[:distribute_to_production]
        full_ipa_path =  "#{ipa_path}/#{app[:output_name]}"
        puts "Release to App Store: #{full_ipa_path}"
        if File.exists?(full_ipa_path)
          upload_to_app_store(
            submit_for_review: false,
            automatic_release: false,
            ipa: full_ipa_path,
            app_version: parseVersionNumber(ENV["VERSION_NUMBER"])[:version],
            build_number: parseVersionNumber(ENV["VERSION_NUMBER"])[:build],
            app_identifier: app[:app_identifier],
          )
        else
          UI.user_error!("ERROR: #{ipa_path} does not exist")
        end
      end
    end
    
  end

end
