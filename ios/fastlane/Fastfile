default_platform(:ios)

puts "ARTIFACT_FOLDER: #{ENV["ARTIFACT_FOLDER"]}"
puts "VERSION_NUMBER: #{ENV["VERSION_NUMBER"]}"

# The path to the .ipa files (artifact staging directory)
# we only set this in the release pipelines, this is a default to prevent errors during the build pipeline
ipa_path = ""
if ENV["ARTIFACT_FOLDER"]
  ipa_path = ENV["ARTIFACT_FOLDER"]
end

# TF_BUILD will be true when this is run in a DevOps pipeline
if ENV["TF_BUILD"]
  xcode_select("/Applications/Xcode_15.0.app")
  setup_ci()
end

# The URL to the repo for Match
git_url = "git@ssh.dev.azure.com:v3/CloudCompetenceCenter/Amsterdam-App/aapp_app_ios-certificates"
if ENV["MATCH_GIT_BEARER_AUTHORIZATION"] || ENV["MATCH_GIT_BASIC_AUTHORIZATION"]
  git_url = "https://CloudCompetenceCenter@dev.azure.com/CloudCompetenceCenter/Amsterdam-App/_git/aapp_app_ios-certificates"
end

# Config for the test and production app
apps = [
  {
    :name => "amsterdam-test",
    :app_identifier => "nl.amsterdam.app.dev",
    :scheme => "AmsterdamApp Test",
    :distribute_to_stakeholders => false,
    :distribute_to_production => false,
    :output_name => "AmsterdamTest.ipa",
  },
  {
    :name => "amsterdam",
    :app_identifier => "nl.amsterdam.app",
    :scheme => "AmsterdamApp",
    :distribute_to_stakeholders => true,
    :distribute_to_production => true,
    :output_name => "Amsterdam.ipa",
  },
]

def parseVersionNumber(fullVersionNumber)
  if fullVersionNumber
    return fullVersionNumber.match /(?<version>\d+\.\d+\.\d+)\.(?<build>\d+)/
  else
    UI.user_error!("ERROR: parseVersionNumber failed")
  end
end

platform :ios do

  private_lane :installAppStoreApiKey do
    app_store_connect_api_key(
        key_id: "4B3KZ8N747",
        issuer_id: "69a6de97-c5e4-47e3-e053-5b8c7c11a4d1",
        key_filepath: './certs/App_Store_Connect_API_Key_4B3KZ8N747.p8',
        duration: 1200,
        in_house: false,
      )
  end

  # options
  #   readonly: boolean (default = false)
  #   type: 'development' | 'appstore' (default = 'development')
  private_lane :syncCertificates do |options|
    
    readonly = options.fetch(:readonly, false)
    type = options.fetch(:type, 'development')

    puts "Sync certificates for #{type}, readonly: #{readonly}"

    if !readonly
      installAppStoreApiKey()
    end

    identifiers = apps.map { |app| app[:app_identifier] }

    match(
      type: type,
      generate_apple_certs: true,
      app_identifier: identifiers,
      git_branch: 'amsterdam-app',
      readonly: readonly,
      skip_certificate_matching: readonly,
      skip_provisioning_profiles: false,
      storage_mode: "git",
      git_url: git_url,
      git_full_name: "Amsterdam App",
      git_user_email: "app@amsterdam.nl",
      force_for_new_devices: true,
      include_mac_in_profiles: true,
      verbose: true,
    )

  end

  desc "Sync development certificates"
  lane :syncDevelopment do |options|
    syncCertificates(options)
  end

  desc "Sync adhoc certificates"
  lane :syncAdhoc do |options|
    syncCertificates(
      **options,
      type: "adhoc",
    )
  end

  desc "Sync appstore certificates"
  lane :syncAppstore do |options|
    syncCertificates(
      **options,
      type: "appstore",
    )
  end

  desc "Sync all certificates"
  lane :syncAll do |options|
    syncDevelopment(options)
    syncAdhoc(options)
    syncAppstore(options)
  end

  desc "Build prod and dev version of the app"
  lane :buildApps do

    # We cannot switch the app identifier for the build_app task via a config setting, in this setup we can only set it for a lane (see Appfile).
    # Hence the multitude of lanes that seemingly do nothing.

    desc "Create single app build"
    private_lane :buildLane do |app|
        build_app(
          workspace: "AmsterdamApp.xcworkspace",
          scheme: app[:scheme],
          clean: true,
          build_path: "./builds",
          output_directory: "./builds",
          output_name: app[:output_name],
        )
    end

    desc "Production build"
    private_lane :prodLane do |app|
      buildLane(app)
    end

    desc "Dev build"
    private_lane :devLane do |app|
      buildLane(app)
    end

    syncAppstore(
      readonly: true,
    )

    cocoapods(
      clean_install: true,
      podfile: "./Podfile",
    )

    apps.each do |app|
      puts "Build #{app[:app_identifier]}"
      if app[:name] == "amsterdam-test"
        devLane(app)
      else
        prodLane(app)
      end
    end

    # TODO set_changelog()
  end

  lane :distributeInternal do

    installAppStoreApiKey()

    apps.each do |app|
      full_ipa_path =  "#{ipa_path}/#{app[:output_name]}"
      puts "Upload to testflight for #{full_ipa_path}"
      if File.exists?(full_ipa_path)
        upload_to_testflight(
          ipa: full_ipa_path,
          app_version: parseVersionNumber(ENV["VERSION_NUMBER"])[:version],
          build_number: parseVersionNumber(ENV["VERSION_NUMBER"])[:build],
          app_identifier: app[:app_identifier],
          groups: "AmsterdamApp-internal",
        )
      else
        UI.user_error!("ERROR: #{ipa_path} does not exist")
      end
    end

  end

  lane :distributeStakeholders do

    installAppStoreApiKey()

    apps.each do |app|
      if app[:distribute_to_stakeholders]
        full_ipa_path =  "#{ipa_path}/#{app[:output_name]}"
        puts "Upload to testflight for #{full_ipa_path}"
        if File.exists?(full_ipa_path)
          upload_to_testflight(
            app_identifier: app[:app_identifier],
            app_version: parseVersionNumber(ENV["VERSION_NUMBER"])[:version],
            build_number: parseVersionNumber(ENV["VERSION_NUMBER"])[:build],
            ipa: full_ipa_path,
            distribute_external: true,
            distribute_only: true,
            groups: "AmsterdamApp-stakeholders",
          )
        else
          UI.user_error!("ERROR: #{ipa_path} does not exist")
        end
      end
    end

  end
  
  lane :distributeProduction do

    installAppStoreApiKey()
 
    # TODO review and fix
    apps.each do |app|
      if app[:distribute_to_production]
        full_ipa_path =  "#{ipa_path}/#{app[:output_name]}"
        puts "Release to App Store: #{full_ipa_path}"
        if File.exists?(full_ipa_path)
          upload_to_app_store(
            submit_for_review: false,
            automatic_release: false,
            ipa: full_ipa_path,
            app_version: parseVersionNumber(ENV["VERSION_NUMBER"])[:version],
            build_number: parseVersionNumber(ENV["VERSION_NUMBER"])[:build],
            app_identifier: app[:app_identifier],
          )
        else
          UI.user_error!("ERROR: #{ipa_path} does not exist")
        end
      end
    end
    
  end

end
